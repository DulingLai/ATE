package dulinglai.android.ate.propagationAnalysis;

import dulinglai.android.ate.propagationAnalysis.intents.Ic3Analysis;
import dulinglai.android.ate.propagationAnalysis.intents.Ic3Config;
import dulinglai.android.ate.propagationAnalysis.parser.ParseException;
import soot.PackManager;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

public abstract class Analysis {

    public Analysis(Ic3Config ic3Config){

    }

    /**
     * Pattern method to perform the analysis.
     *
     */
    public void performAnalysis(Ic3Config ic3Config) {
        try {
            PropagationTimers.v().modelParsing.start();
            loadModel(ic3Config);
            PropagationTimers.v().modelParsing.end();
            PropagationTimers.v().misc.start();
            registerFieldTransformerFactories(ic3Config);
            registerArgumentValueAnalyses(ic3Config);
            registerMethodReturnValueAnalyses(ic3Config);
            setApplicationClasses(ic3Config);
            PropagationTimers.v().misc.end();
            initializeAnalysis(ic3Config);
            PropagationTimers.v().soot.start();
            PackManager.v().runPacks();
            PropagationTimers.v().soot.end();
            processResults(ic3Config);
            finalizeAnalysis(ic3Config);
        } catch (FatalAnalysisException e) {
            handleFatalAnalysisException(ic3Config, e);
        }
    }

    /**
     * Loads the COAL model to be used for the analysis. The model can be stored either in a directory
     * with a flat structure (no subdirectories) or in a compiled (serialized) format.
     *
     * @param ic3Config The IC3 configuration
     * @throws FatalAnalysisException if a fatal error occurs.
     */
    protected void loadModel(Ic3Config ic3Config) throws FatalAnalysisException {
        try {
            if (ic3Config.getCompiledModel() != null) {
                Model.loadModelFromCompiledFile(ic3Config.getCompiledModel());
            } else if (ic3Config.getModel() != null) {
                Model.loadModel(ic3Config.getModel());
            } else {
                throw new FatalAnalysisException("No model file or directory was specified");
            }
        } catch (ClassNotFoundException | IOException | ParseException e) {
            throw new FatalAnalysisException("Could not load model", e);
        }
    }

    /**
     * Registers the field transformer factories for the analysis. A
     * {@link dulinglai.android.ate.propagationAnalysis.fields.transformers.FieldTransformer FieldTransformer} specifies
     * how a field is modified by a method. For each possible FieldTransformer type, a
     * {@link dulinglai.android.ate.propagationAnalysis.fields.transformers.FieldTransformerFactory
     * FieldTransformerFactory} should be declared to instantiate the FieldTransformer as appropriate.
     *
     * @param ic3Config A {@link Ic3Config} subclass object that represents the
     *          IC3 config for this analysis.
     * @throws FatalAnalysisException if a fatal error occurs.
     */
    protected abstract void registerFieldTransformerFactories(Ic3Config ic3Config)
            throws FatalAnalysisException;

    /**
     * Registers the method argument value analyses.
     * {@link dulinglai.android.ate.propagationAnalysis.fields.transformers.FieldTransformer FieldTransformer} objects are
     * generated by {@link dulinglai.android.ate.propagationAnalysis.fields.transformers.FieldTransformerFactory
     * FieldTransformerFactory} objects using both a COAL specification and most often a method
     * argument value. This method specifies which
     * {@link dulinglai.android.ate.propagationAnalysis.arguments.ArgumentValueAnalysis ArgumentValueAnalysis} is in
     * charge of handling every argument type using the
     * {@link dulinglai.android.ate.propagationAnalysis.arguments.ArgumentValueManager#registerArgumentValueAnalysis
     * registerArgumentValueAnalysis} method.
     *
     * @param  ic3Config {@link Ic3Config} subclass object that represents the
     *          command line arguments for this analysis.
     * @throws FatalAnalysisException if a fatal error occurs.
     */
    protected abstract void registerArgumentValueAnalyses(Ic3Config ic3Config)
            throws FatalAnalysisException;

    /**
     * Registers method return value analyses. When the return value of a method is always known and
     * the method should not be traversed, a
     * {@link dulinglai.android.ate.propagationAnalysis.arguments.MethodReturnValueAnalysis MethodReturnValueAnalysis} can
     * be registered to specify the return value with the
     * {@link dulinglai.android.ate.propagationAnalysis.arguments.MethodReturnValueManager#registerMethodReturnValueAnalysis
     * registerMethodReturnValueAnalysis} method.
     *
     * @param ic3Config A {@link Ic3Config} subclass object that represents the
     *          command line arguments for this analysis.
     * @throws FatalAnalysisException if a fatal error occurs.
     */
    protected abstract void registerMethodReturnValueAnalyses(Ic3Config ic3Config)
            throws FatalAnalysisException;

    /**
     * Registers the application classes through which the propagation should take place. By default,
     * this is the list of classes in the input directory or jar file. By default, it also includes
     * the list of modeled classes if it was requested on the command line.
     *
     * @param ic3Config A {@link Ic3Config} subclass object that represents the
     *          command line arguments for this analysis.
     * @throws FatalAnalysisException if a fatal error occurs.
     */
    protected void setApplicationClasses(Ic3Config ic3Config) throws FatalAnalysisException {
        AnalysisParameters.v().addAnalysisClasses(
                computeAnalysisClasses(ic3Config.getInput()));
        if (ic3Config.traverseModeled()) {
            AnalysisParameters.v().addAnalysisClasses(Model.v().getModeledTypes());
        }
    }

    /**
     * Initializes the analysis, including Soot parameters (pointer analysis, etc.).
     *
     * @param ic3Config A {@link Ic3Config} subclass object that represents the
     *          command line arguments for this analysis.
     * @throws FatalAnalysisException if a fatal error occurs.
     */
    protected abstract void initializeAnalysis(Ic3Config ic3Config) throws FatalAnalysisException;

    /**
     * Processes the results of the analysis.
     *
     * @param ic3Config A {@link Ic3Config} subclass object that represents the
     *          command line arguments for this analysis.
     * @throws FatalAnalysisException if a fatal error occurs.
     */
    protected abstract void processResults(Ic3Config ic3Config) throws FatalAnalysisException;

    /**
     * Finalizes the analysis. This should be used for example to close open files.
     *
     * @param ic3Config A {@link Ic3Config} subclass object that represents the
     *          command line arguments for this analysis.
     * @throws FatalAnalysisException if a fatal error occurs.
     */
    protected abstract void finalizeAnalysis(Ic3Config ic3Config) throws FatalAnalysisException;

    /**
     * Handles a fatal analysis exception. A {@link FatalAnalysisException} occurs when something
     * serious prevents the analysis from proceeding. This exception is caught at a higher level to
     * allow some things to be wrapped up (e.g., closing files or database connections). This method
     * specifies the wrapping up process.
     *
     * @param ic3Config A {@link Ic3Config} subclass object that represents the
     *          command line arguments for this analysis.
     * @param exception A {@link FatalAnalysisException}.
     */
    protected abstract void handleFatalAnalysisException(Ic3Config ic3Config,
                                                         FatalAnalysisException exception);

    /**
     * Computes the set of classes in a directory or a jar file. This method computes the fully
     * qualified Java name of all the classes under a given directory. The class files can be in
     * multiple packages.
     *
     * @param dirOrJar A directory or jar path.
     * @return The set of classes in the input directory.
     * @throws FatalAnalysisException if something goes wrong with the file operations.
     */
    protected Set<String> computeAnalysisClasses(String dirOrJar) throws FatalAnalysisException {
        try {
            File file = new File(dirOrJar);

            if (file.isDirectory()) {
                String directoryString = file.getCanonicalPath();
                int basePos = directoryString.length() + 1;
                return computeAnalysisClassesInDir(file, basePos);
            } else {
                return computeAnalysisClassesInJar(file);
            }
        } catch (IOException e) {
            e.printStackTrace();
            throw new FatalAnalysisException(e);
        }
    }

    /**
     * Helper for computing the set of classes in a directory.
     *
     * @param directory A {@link java.io.File File} object for the directory under which classes
     *          should be searched for.
     * @param basePos The position of the first letter for the Java package names in the directory's
     *          absolute path. For example, if the current directory is <code>/home/foo/bar</code>,
     *          but the top-level directory where all Java packages are located is
     *          <code>/home/foo</code>, then the <code>basePos</code> would be 10, which is the index
     *          of the <code>b</code> character.
     * @return The set of classes found under the directory.
     * @throws IOException if something goes wrong with the file operations.
     */
    private Set<String> computeAnalysisClassesInDir(File directory, int basePos) throws IOException {
        File[] nestedFilesAndDirs = directory.listFiles();
        Set<String> result = new HashSet<String>();

        for (File nestedFile : nestedFilesAndDirs) {
            if (nestedFile.isDirectory()) {
                result.addAll(computeAnalysisClassesInDir(nestedFile, basePos));
            } else {
                String canonicalPath = nestedFile.getCanonicalPath();
                if (canonicalPath.endsWith(".class")) {
                    result
                            .add(canonicalPath.substring(basePos, canonicalPath.length() - 6).replace('/', '.'));
                }
            }
        }

        return result;
    }

    /**
     * Helper for computing the set of classes in a jar file.
     *
     * @param file A {@link java.io.File File} object for the jar in which classes should be searched
     *          for.
     * @return The set of classes found in the jar.
     * @throws IOException if something goes wrong with the file operations.
     */
    private Set<String> computeAnalysisClassesInJar(File file) throws IOException {
        Set<String> result = new HashSet<>();

        JarFile jarFile = new JarFile(file);
        Enumeration<JarEntry> jarEntries = jarFile.entries();

        while (jarEntries.hasMoreElements()) {
            JarEntry jarEntry = jarEntries.nextElement();
            String entryName = jarEntry.getName();
            if (entryName.endsWith(".class")) {
                String name = entryName.substring(0, entryName.length() - 6).replace('/', '.');
                result.add(name);
            }
        }

        jarFile.close();

        return result;
    }
}
